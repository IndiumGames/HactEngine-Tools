#!/usr/bin/env python

"""
Run SWIG.

The files used for the generation are cached, and the differences between the
real and the cached versions are compared. If the timestamps on the files
haven't changed, SWIG is not run.
"""

import argparse
import filecmp
import glob
import os
import posixpath
import shutil
import subprocess
import sys


parser = argparse.ArgumentParser()
parser.add_argument(
    "--release",
    help = "Generate code for release build",
    action = "store_true",
    default = False
)
parser.add_argument(
    "inputFile",
    help = "SWIG input file to use (required)"
)
parser.add_argument(
    "dependencyFiles",
    nargs = "*",
    default = [],
    help = "Files that the input file depends on. If any of these files is "
           + "modified, SWIG is forced to run (optional)"
)
args = parser.parse_args()


inputFile  = args.inputFile
outputFile = inputFile.replace(".i", "_wrap.cxx")

if args.release:
    outputFile = "../../build/Release/" + outputFile
else:
    outputFile = "../../build/Debug/" + outputFile

if "swig_hact.i" in inputFile:
    swigCommand = [
        "swig",
        "-I../..",
        "-I../../thirdparty",
        "-c++",
        "-lua",
        "-v",
        "-no-old-metatable-bindings",
        "-o",
        outputFile,
        inputFile
    ]
else:
    swigCommand = [
        "swig",
        "-I../..",
        "-I../../thirdparty",
        "-c++",
        "-lua",
        "-v",
        # TODO: Get this to work...
        #"-nomoduleglobal",
        "-no-old-metatable-bindings",
        "-o",
        outputFile,
        inputFile
    ]

cacheDir = ".swig-cache/Release_" + inputFile

if not args.release:
    swigCommand.insert(1, "-DHACT_EDITORS")
    cacheDir = ".swig-cache/Debug_" + inputFile

# If any of these files have changed, SWIG needs to run again
dependencyFiles = [glob.glob(pattern) for pattern in args.dependencyFiles]
dependencyFiles = [dependencyFile for sublist in dependencyFiles for dependencyFile in sublist]

# Add the input file into the dependency file list
dependencyFiles += [inputFile]


# If this becomes true, SWIG needs to run
runNecessary = False

if not posixpath.exists(cacheDir):
    # Create cache directory
    runNecessary = True
    os.makedirs(cacheDir)
    
    print("Create cache dir, run necessary")
elif not posixpath.exists(outputFile):
    # The output file doesn't exist yet
    runNecessary = True
    
    print("Output file doesn't exist, run necessary")

# Loop over dependency files
for dependencyFile in dependencyFiles:
    if not posixpath.exists(dependencyFile):
        sys.exit("Missing dependency file: " + dependencyFile)
    
    cachedFile = cacheDir + "/" + posixpath.basename(dependencyFile)
    
    if not posixpath.exists(cachedFile):
        # The dependent file hasn't been cached yet
        runNecessary = True
        shutil.copyfile(dependencyFile, cachedFile)
        
        print(
            "Dependency file '"
            + dependencyFile
            + "' not cached yet, run necessary"
        )
    elif posixpath.getmtime(cachedFile) < posixpath.getmtime(dependencyFile):
        # The cached file is older than the dependency file
        print(
            "Cached file for '"
            + dependencyFile
            + "' is older, replacing with new file"
        )
        
        if not runNecessary and not filecmp.cmp(cachedFile, dependencyFile):
            runNecessary = True
            shutil.copyfile(dependencyFile, cachedFile)
            
            print(
                "Cached file for '"
                + dependencyFile
                + "' is older and different content, run necessary"
            )
        
        shutil.copyfile(dependencyFile, cachedFile)


if runNecessary:
    print("Running SWIG for " + inputFile)
    subprocess.call(swigCommand)
else:
    print("Running SWIG is not necessary for " + inputFile)
